\documentclass[12pt]{article}
\usepackage{../eplcrypto}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
% \geometry{landscape} % rotated page geometry
\usepackage[parfill]{parskip}
% See the ``Article customise'' template for come common customisations
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{algorithm}
\title{Slides09}

%%% BEGIN DOCUMENT
\begin{document}

\maketitle
\tableofcontents
\newpage


\section{The RSA signature}
\subsection{The RSA problem}
\subsubsection{Experiment: $\RSAinv$}
\begin{itemize}
	\item $\langle (N,e),(N,d)\rangle \leftarrow \Gen(1^n)$
	\item $y\leftarrow \ZZ_N^*$
	\item $x \leftarrow \A(N,e,y)$
	\item Define $\RSAinv(n) \define \iff x^e = y \bmod{N}$
\end{itemize}
Assumption:
\begin{itemize}
	\item $\forall$ PPT $\A$, $\exists$ negl. $\negl$ s.t.:
	\begin{equation*}
		Pr[\RSAinv(n)=1] \le \negl(n)
	\end{equation*}
	\item The RSA problem is believed to be hard
	\item Not known to be equivalent to factoring
	\item Best choice for N: Product of two large prime factors
\end{itemize}

\subsection{Building a signature scheme with RSA}
\subsubsection{Simple proposal}
\begin{itemize}
	\item $\Gen(1^n)\define \langle (N,e), (N,d)\rangle $ with $|p|=|p|=n$
	\item $\Sign_{(N,d)}(m) \define [m^d \bmod{N}]$
	\item $\Vrfy_{(N,e)}(m,\sigma) \define [\sigma^e =^? m \bmod{N}]$
\end{itemize}
This simple proposal works, but it is not secure:
\begin{itemize}
	\item No-message attack
	\begin{itemize}
		\item Take $\sigma$ at random
		\item Compute $m \define \sigma^e \bmod{N}$
		\item $(m,\sigma)$ is a forgery
	\end{itemize}
	\item Signature combination
	\begin{itemize}
		\item Suppose $\A$ wants to forge a signature on $m$
		\item $\A$ chooses $m_1$ at random and obtains signature $\sigma_1$
		\item $\A$ computes $m_2 \define m/m_1 \bmod{N}$ and obtains signature $\sigma_2$
		\item Now $\sigma \define \sigma_1 \cdot \sigma_2 \bmod{N}$ is a valid signature on $m$
	\end{itemize}	
\end{itemize}

\subsubsection{Hashed RSA}
Hash the message before applying RSA:
\begin{equation*}
	\sigma(m) \define H(m)^d \bmod{N}
\end{equation*}
Verification is simple:
\begin{equation*}
	\sigma^e =^? H(m) \bmod{N}
\end{equation*}
$H$ must be collision resistant, otherwise one could forge a signature for $m$ from the signature of $m'$ s.t. $H(m)=H(m')$.\\
This construction avoids the attacks that simple scheme suffered in the previous subsection.
\begin{itemize}
	\item No-message attack
	\begin{itemize}
		\item $\A$ would need to find $m$ s.t. $H(m) = \sigma^e \bmod{N}$. This is difficult if $H$ is pre-image resistant.
	\end{itemize}
	\item Signature combination
	\begin{itemize}
		\item $\A$ would need to find $m,m_1,m_2$ s.t.\\
		$H(m) = H(m_1)\cdot H(m_1)\bmod{N} $ which seems difficult for traditional hash functions.
	\end{itemize}	
\end{itemize}
Can we prove that this works $=>$ No. There is no expected propery of $H$ for which hashed RSA signatures can be proven secure in the sense of our definition for hash functions.
\newpage


\section{RSA-FDH}
Define \textbf{RSA-FDH} scheme $\Pi$ as follows.
\begin{itemize}
	\item $\Gen$:  $\langle (N,e,d)\rangle \leftarrow RSA(1^n)$
	\item $\Sign$: On input $(N,d)$ and $m\in \bset^*$, output\\
	$\sigma \define H(m)^d \bmod{N}$
	\item $\Vrfy$ On input $(N,e),m \in \bset^*$ and $\sigma$, output 1 iff\\  $[\sigma^e =^? m \bmod{N}]$
\end{itemize}
\textbf{Theorem:} If the RSA problem is hard, then $\Pi$ is EUF-CMA in the ROM


\section{Encrypting with RSA}
RSA can also be used as a public key encryption scheme (with some addition of randomness). 
\subsection{Padded RSA}
\begin{itemize}
	\item $|m| \in \bset^{\frac{|N|}{2}-2}$ and $r\leftarrow \bset^{|N|-|m|-1}$\\
	$\Enc_{N,e}(m) \define (r||m)^e \bmod{N}$
	\item $\Dec_{N,d}(c) \define c^d \bmod{N}$
\end{itemize}
This is believed to be CPA-secure if the RSA problem is hard.

\section{Certificates and PKI}
The key notion here is a digital certificate, which is simply a signature binding an entity to some public key.
Principle:
\begin{itemize}
	\item Bob generates a key pair $pk,sk$
	\item Bob meets Charlie and convinces him that he is Bob and that $pk$ is his public key
	\item Charlie gives $\cert_{C\rightarrow B}$
	\item Bob can now use $\cert_{C\rightarrow B}$ to introduce himself to anyone who knows Charlie
\end{itemize}
$\cert_{C\rightarrow B}$ is called certificate for Bob's key issued by Charlie: $\Sign_{sk_C}(\text{Bob's key is }pk_B )$
\newpage
Alice must be convinced:
\begin{itemize}
	\item That Charlie's key is $pk_C$
	\item That Charlie is honest
	\item That Charlie does check Bob's identity before issuing $\cert_{C\rightarrow B}$
\end{itemize}
Alice considers Charlie as a \emph{certification authority (CA)}

The certification relationship can be chained:
\begin{itemize}
	\item Bob provides Alice with $pk_B$, $\cert_{C\rightarrow B}$, $\cert_{D\rightarrow C}$, $\cert_{E\rightarrow D}$
	\item If Alice:
	\begin{itemize}
		\item Has a copy of $pk_E$, and knows it is authentic
		\item And knows that C,D,E are good CAs
	\end{itemize}
	Then she can conclude that Bob's public key is $pk_B$
\end{itemize}


\subsection{Hierarchic PKI}
A CA often develops an internal hierarchy:
\begin{itemize}
	\item High-level (super-protected) root CA
	\item Mid-level CAs, certified by higher levels
\end{itemize}

Root CA's key must be transmitted in a secure way
\begin{itemize}
	\item Hand-to-hand given when entering a company
	\item Embedded in web browser
	\item Embedded in operating system
\end{itemize}



\subsection{Flat PKI}
I trust someone's key:
\begin{itemize}
	\item Because I met him personally
	\item Or because I trust the key of someone who trusts him
	\item A recursive relationship
\end{itemize}
Trust level can be associated to each contact (possible to use combined trust)

First-hand certificates must be distributed in a secure way.
\begin{itemize}
	\item Face-to-face meeting (key signing parties)
	\item Read over the phone (key fingerprint)
\end{itemize}

Typical example: PGP


































\end{document}